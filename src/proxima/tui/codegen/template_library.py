"""Template Library for Backend Code Generation.

Provides comprehensive templates for all backend types and components.
Phase 3 implementation with production-ready templates.
"""

from __future__ import annotations

from typing import Dict, Any
from dataclasses import dataclass
from enum import Enum


class TemplateType(Enum):
    """Types of templates available."""
    ADAPTER = "adapter"
    NORMALIZER = "normalizer"
    CONVERTER = "converter"
    ERRORS = "errors"
    INIT = "init"
    README = "readme"
    TESTS = "tests"
    CONFIG = "config"


@dataclass
class TemplateMetadata:
    """Metadata for a template."""
    name: str
    template_type: TemplateType
    description: str
    required_vars: list
    optional_vars: list


class TemplateLibrary:
    """Library of all backend templates.
    
    Provides access to templates for:
    - Python Library backends
    - Command Line backends
    - API Server backends
    - Custom backends
    
    Each template is production-ready with comprehensive
    error handling, logging, and documentation.
    """
    
    def get_template(self, template_type: TemplateType, backend_type: str) -> str:
        """Get a template by type and backend type.
        
        Args:
            template_type: Type of template
            backend_type: Backend type (python_library, command_line, etc.)
            
        Returns:
            Template string
        """
        templates = {
            (TemplateType.ADAPTER, "python_library"): PYTHON_LIBRARY_ADAPTER,
            (TemplateType.ADAPTER, "command_line"): COMMAND_LINE_ADAPTER,
            (TemplateType.ADAPTER, "api_server"): API_SERVER_ADAPTER,
            (TemplateType.ADAPTER, "custom"): CUSTOM_ADAPTER,
            (TemplateType.NORMALIZER, None): NORMALIZER,
            (TemplateType.CONVERTER, None): CONVERTER,
            (TemplateType.ERRORS, None): ERRORS,
            (TemplateType.INIT, None): INIT,
            (TemplateType.README, None): README,
            (TemplateType.TESTS, None): TESTS,
            (TemplateType.CONFIG, None): CONFIG,
        }
        
        # Try specific backend type first
        template = templates.get((template_type, backend_type))
        if template:
            return template
        
        # Fall back to generic template
        return templates.get((template_type, None), "")
    
    def get_metadata(self, template_type: TemplateType) -> TemplateMetadata:
        """Get metadata for a template type."""
        metadata = {
            TemplateType.ADAPTER: TemplateMetadata(
                name="Adapter",
                template_type=TemplateType.ADAPTER,
                description="Main backend adapter class",
                required_vars=["backend_name", "display_name", "version"],
                optional_vars=["author", "description", "library_name", "max_qubits"]
            ),
            TemplateType.NORMALIZER: TemplateMetadata(
                name="Normalizer",
                template_type=TemplateType.NORMALIZER,
                description="Result normalization class",
                required_vars=["backend_name", "display_name"],
                optional_vars=[]
            ),
            TemplateType.TESTS: TemplateMetadata(
                name="Tests",
                template_type=TemplateType.TESTS,
                description="Unit test file",
                required_vars=["backend_name", "display_name"],
                optional_vars=["max_qubits"]
            ),
        }
        return metadata.get(template_type)


# =============================================================================
# PYTHON LIBRARY ADAPTER TEMPLATE
# =============================================================================

PYTHON_LIBRARY_ADAPTER = '''"""${display_name} Backend Adapter.

Auto-generated by Proxima Backend Wizard (Phase 3).
Backend Type: Python Library
Version: ${version}
${author_line}

${description}
"""

from __future__ import annotations

from typing import Any, Dict, List, Optional, Tuple
import logging
import time
import functools

from proxima.backends.base import (
    BaseBackendAdapter,
    Capabilities,
    SimulatorType,
    ValidationResult,
    ResourceEstimate,
    ExecutionResult,
    ResultType,
)
from .errors import (
    BackendError,
    InitializationError,
    ExecutionError,
    ValidationError,
    ResourceError,
)
from .normalizer import ${class_name}Normalizer

logger = logging.getLogger(__name__)


def retry(max_attempts: int = 3, delay: float = 1.0):
    """Decorator to retry failed operations."""
    def decorator(func):
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            last_exception = None
            for attempt in range(max_attempts):
                try:
                    return func(*args, **kwargs)
                except Exception as e:
                    last_exception = e
                    if attempt < max_attempts - 1:
                        time.sleep(delay * (attempt + 1))
            raise last_exception
        return wrapper
    return decorator


class ${class_name}Adapter(BaseBackendAdapter):
    """Adapter for ${display_name}.
    
    ${description}
    
    Attributes:
        name: Backend identifier
        version: Backend version string
        config: Configuration dictionary
    """
    
    name = "${backend_name}"
    version = "${version}"
    
    # Gate mappings from Proxima to backend format
    GATE_MAPPING = {
        "H": "hadamard",
        "X": "pauli_x",
        "Y": "pauli_y",
        "Z": "pauli_z",
        "CNOT": "cnot",
        "CX": "cx",
        "CZ": "cz",
        "SWAP": "swap",
        "RX": "rx",
        "RY": "ry",
        "RZ": "rz",
        "S": "s",
        "T": "t",
        "CCX": "toffoli",
    }
    
    def __init__(self, config: Dict[str, Any] = None):
        """Initialize the ${display_name} adapter.
        
        Args:
            config: Optional configuration dictionary
        """
        self.config = config or {}
        self._simulator = None
        self._initialized = False
        self._normalizer = ${class_name}Normalizer()
        logger.info(f"Created {self.name} adapter v{self.version}")
    
    def get_name(self) -> str:
        """Return backend identifier."""
        return self.name
    
    def get_version(self) -> str:
        """Return backend version string."""
        return self.version
    
    def get_capabilities(self) -> Capabilities:
        """Return supported capabilities."""
        return Capabilities(
            simulator_types=[
                SimulatorType.STATE_VECTOR,
                ${additional_sim_types}
            ],
            max_qubits=${max_qubits},
            supports_noise=${supports_noise},
            supports_gpu=${supports_gpu},
            supports_batching=${supports_batching},
        )
    
    def initialize(self) -> None:
        """Initialize the backend.
        
        Raises:
            InitializationError: If initialization fails
        """
        if self._initialized:
            return
        
        try:
            import ${library_name}
            
            # Create simulator instance
            sim_config = self.config.get('simulator', {})
            self._simulator = ${library_name}.Simulator(**sim_config)
            
            # Verify simulator is working
            if hasattr(self._simulator, 'ping'):
                self._simulator.ping()
            
            self._initialized = True
            logger.info(f"Initialized {self.name} backend with ${library_name}")
            
        except ImportError as e:
            raise InitializationError(
                f"${library_name} not installed. "
                f"Install with: pip install ${library_name}"
            ) from e
        except Exception as e:
            raise InitializationError(
                f"Failed to initialize ${display_name}: {e}"
            ) from e
    
    def validate_circuit(self, circuit: Any) -> ValidationResult:
        """Validate circuit compatibility with the backend.
        
        Args:
            circuit: Circuit to validate
            
        Returns:
            ValidationResult with validity and message
        """
        # Null check
        if not circuit:
            return ValidationResult(
                valid=False,
                message="Circuit is None or empty"
            )
        
        # Qubit count check
        num_qubits = getattr(circuit, 'num_qubits', 0)
        if num_qubits > ${max_qubits}:
            return ValidationResult(
                valid=False,
                message=f"Circuit has {num_qubits} qubits, maximum is ${max_qubits}"
            )
        
        if num_qubits < 1:
            return ValidationResult(
                valid=False,
                message="Circuit must have at least 1 qubit"
            )
        
        # Gate support check
        unsupported = []
        for gate in getattr(circuit, 'gates', []):
            gate_name = getattr(gate, 'name', '').upper()
            if gate_name not in self.GATE_MAPPING:
                unsupported.append(gate_name)
        
        if unsupported:
            return ValidationResult(
                valid=False,
                message=f"Unsupported gates: {', '.join(set(unsupported))}"
            )
        
        return ValidationResult(valid=True, message="Circuit is valid")
    
    def estimate_resources(self, circuit: Any) -> ResourceEstimate:
        """Estimate resources for circuit execution.
        
        Args:
            circuit: Circuit to estimate
            
        Returns:
            ResourceEstimate with memory and time estimates
        """
        num_qubits = getattr(circuit, 'num_qubits', 0)
        gate_count = len(getattr(circuit, 'gates', []))
        
        # Memory: 2^n * 16 bytes for complex state vector
        memory_mb = (2 ** num_qubits * 16) / (1024 * 1024)
        
        # Time estimate based on gates and qubits
        time_ms = gate_count * 0.1 + (2 ** num_qubits) * 0.01
        
        return ResourceEstimate(
            memory_mb=memory_mb,
            time_ms=time_ms,
        )
    
    @retry(max_attempts=3, delay=0.5)
    def execute(
        self,
        circuit: Any,
        options: Dict[str, Any] = None
    ) -> ExecutionResult:
        """Execute a quantum circuit.
        
        Args:
            circuit: Circuit to execute
            options: Execution options (shots, etc.)
            
        Returns:
            ExecutionResult with measurement data
            
        Raises:
            ExecutionError: If execution fails
        """
        if not self._initialized:
            self.initialize()
        
        options = options or {}
        shots = options.get('shots', 1024)
        
        # Validate circuit first
        validation = self.validate_circuit(circuit)
        if not validation.valid:
            raise ValidationError(validation.message)
        
        start_time = time.time()
        
        try:
            # Convert circuit to backend format
            native_circuit = self._convert_circuit(circuit)
            
            # Execute on simulator
            raw_result = self._simulator.run(
                native_circuit,
                shots=shots,
                **options.get('backend_options', {})
            )
            
            # Normalize results
            normalized = self._normalizer.normalize(raw_result)
            
        except Exception as e:
            logger.error(f"Execution failed: {e}")
            raise ExecutionError(f"Circuit execution failed: {e}") from e
        
        execution_time = (time.time() - start_time) * 1000
        
        return ExecutionResult(
            backend=self.name,
            simulator_type=SimulatorType.STATE_VECTOR,
            execution_time_ms=execution_time,
            qubit_count=getattr(circuit, 'num_qubits', 0),
            shot_count=shots,
            result_type=ResultType.COUNTS,
            data=normalized,
            raw_result=raw_result,
        )
    
    def _convert_circuit(self, circuit: Any) -> Any:
        """Convert Proxima circuit to backend format.
        
        Args:
            circuit: Proxima QuantumCircuit
            
        Returns:
            Backend-specific circuit
        """
        import ${library_name}
        
        # Create native circuit
        native = ${library_name}.Circuit(circuit.num_qubits)
        
        # Convert gates
        for gate in circuit.gates:
            gate_name = gate.name.upper()
            backend_name = self.GATE_MAPPING.get(gate_name, gate_name.lower())
            
            gate_method = getattr(native, backend_name, None)
            if gate_method:
                params = getattr(gate, 'params', [])
                qubits = gate.qubits
                
                if params:
                    gate_method(*qubits, *params)
                else:
                    gate_method(*qubits)
            else:
                logger.warning(f"Gate {gate_name} not found, skipping")
        
        return native
    
    def supports_simulator(self, sim_type: SimulatorType) -> bool:
        """Check if simulator type is supported."""
        supported = [SimulatorType.STATE_VECTOR]
        return sim_type in supported
    
    def is_available(self) -> bool:
        """Check if backend is available on this system."""
        try:
            import ${library_name}
            return True
        except ImportError:
            return False
    
    def cleanup(self) -> None:
        """Clean up backend resources."""
        if self._simulator:
            if hasattr(self._simulator, 'close'):
                self._simulator.close()
            if hasattr(self._simulator, 'shutdown'):
                self._simulator.shutdown()
            self._simulator = None
        
        self._initialized = False
        logger.info(f"Cleaned up {self.name} backend")
    
    def __enter__(self):
        """Context manager entry."""
        self.initialize()
        return self
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        """Context manager exit."""
        self.cleanup()
        return False
'''


# =============================================================================
# COMMAND LINE ADAPTER TEMPLATE
# =============================================================================

COMMAND_LINE_ADAPTER = '''"""${display_name} Backend Adapter.

Auto-generated by Proxima Backend Wizard (Phase 3).
Backend Type: Command Line Tool
Version: ${version}
${author_line}

${description}
"""

from __future__ import annotations

from typing import Any, Dict, List, Optional
import logging
import time
import subprocess
import tempfile
import json
import shutil
from pathlib import Path

from proxima.backends.base import (
    BaseBackendAdapter,
    Capabilities,
    SimulatorType,
    ValidationResult,
    ResourceEstimate,
    ExecutionResult,
    ResultType,
)
from .errors import (
    BackendError,
    InitializationError,
    ExecutionError,
    ValidationError,
)
from .normalizer import ${class_name}Normalizer

logger = logging.getLogger(__name__)


class ${class_name}Adapter(BaseBackendAdapter):
    """Command-line adapter for ${display_name}.
    
    ${description}
    
    This adapter wraps a command-line quantum simulation tool
    and handles circuit conversion, execution, and result parsing.
    """
    
    name = "${backend_name}"
    version = "${version}"
    
    # Command-line tool configuration
    TOOL_NAME = "${tool_name}"
    TOOL_COMMAND = "${tool_command}"
    
    def __init__(self, config: Dict[str, Any] = None):
        """Initialize the command-line adapter.
        
        Args:
            config: Configuration with tool path, options, etc.
        """
        self.config = config or {}
        self._tool_path = None
        self._initialized = False
        self._normalizer = ${class_name}Normalizer()
        self._temp_dir = None
        logger.info(f"Created {self.name} CLI adapter v{self.version}")
    
    def get_name(self) -> str:
        return self.name
    
    def get_version(self) -> str:
        return self.version
    
    def get_capabilities(self) -> Capabilities:
        return Capabilities(
            simulator_types=[SimulatorType.STATE_VECTOR],
            max_qubits=${max_qubits},
            supports_noise=${supports_noise},
            supports_gpu=${supports_gpu},
            supports_batching=False,
        )
    
    def initialize(self) -> None:
        """Initialize by verifying tool is available."""
        if self._initialized:
            return
        
        # Find tool
        tool_path = self.config.get('tool_path', self.TOOL_COMMAND)
        self._tool_path = shutil.which(tool_path)
        
        if not self._tool_path:
            raise InitializationError(
                f"Command-line tool '{tool_path}' not found. "
                f"Please install {self.TOOL_NAME} and add to PATH."
            )
        
        # Verify tool works
        try:
            result = subprocess.run(
                [self._tool_path, "--version"],
                capture_output=True,
                text=True,
                timeout=10
            )
            if result.returncode != 0:
                raise InitializationError(
                    f"Tool returned error: {result.stderr}"
                )
        except subprocess.TimeoutExpired:
            raise InitializationError("Tool timed out during version check")
        except Exception as e:
            raise InitializationError(f"Failed to verify tool: {e}")
        
        # Create temp directory for circuit files
        self._temp_dir = tempfile.mkdtemp(prefix="${backend_name}_")
        
        self._initialized = True
        logger.info(f"Initialized {self.name} with tool at {self._tool_path}")
    
    def validate_circuit(self, circuit: Any) -> ValidationResult:
        """Validate circuit for command-line execution."""
        if not circuit:
            return ValidationResult(valid=False, message="Circuit is empty")
        
        num_qubits = getattr(circuit, 'num_qubits', 0)
        if num_qubits > ${max_qubits}:
            return ValidationResult(
                valid=False,
                message=f"Too many qubits: {num_qubits} > ${max_qubits}"
            )
        
        return ValidationResult(valid=True)
    
    def estimate_resources(self, circuit: Any) -> ResourceEstimate:
        num_qubits = getattr(circuit, 'num_qubits', 0)
        return ResourceEstimate(
            memory_mb=(2 ** num_qubits * 16) / (1024 * 1024),
            time_ms=1000,  # CLI tools have overhead
        )
    
    def execute(
        self,
        circuit: Any,
        options: Dict[str, Any] = None
    ) -> ExecutionResult:
        """Execute circuit via command-line tool."""
        if not self._initialized:
            self.initialize()
        
        options = options or {}
        shots = options.get('shots', 1024)
        
        start_time = time.time()
        
        # Save circuit to file
        circuit_file = Path(self._temp_dir) / "circuit.json"
        output_file = Path(self._temp_dir) / "result.json"
        
        circuit_data = self._convert_to_json(circuit)
        circuit_file.write_text(json.dumps(circuit_data))
        
        # Build command
        cmd = [
            self._tool_path,
            "run",
            str(circuit_file),
            "--shots", str(shots),
            "--output", str(output_file),
        ]
        
        # Add extra options
        for key, value in options.get('cli_options', {}).items():
            cmd.extend([f"--{key}", str(value)])
        
        try:
            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                timeout=options.get('timeout', 300)
            )
            
            if result.returncode != 0:
                raise ExecutionError(f"Tool error: {result.stderr}")
            
            # Read results
            raw_result = json.loads(output_file.read_text())
            
        except subprocess.TimeoutExpired:
            raise ExecutionError("Execution timed out")
        except json.JSONDecodeError as e:
            raise ExecutionError(f"Failed to parse results: {e}")
        except Exception as e:
            raise ExecutionError(f"Execution failed: {e}")
        
        execution_time = (time.time() - start_time) * 1000
        normalized = self._normalizer.normalize(raw_result)
        
        return ExecutionResult(
            backend=self.name,
            simulator_type=SimulatorType.STATE_VECTOR,
            execution_time_ms=execution_time,
            qubit_count=getattr(circuit, 'num_qubits', 0),
            shot_count=shots,
            result_type=ResultType.COUNTS,
            data=normalized,
            raw_result=raw_result,
        )
    
    def _convert_to_json(self, circuit: Any) -> Dict[str, Any]:
        """Convert circuit to JSON format."""
        gates = []
        for gate in getattr(circuit, 'gates', []):
            gates.append({
                'name': gate.name,
                'qubits': list(gate.qubits),
                'params': list(getattr(gate, 'params', []))
            })
        
        return {
            'num_qubits': getattr(circuit, 'num_qubits', 0),
            'gates': gates
        }
    
    def supports_simulator(self, sim_type: SimulatorType) -> bool:
        return sim_type == SimulatorType.STATE_VECTOR
    
    def is_available(self) -> bool:
        return shutil.which(self.TOOL_COMMAND) is not None
    
    def cleanup(self) -> None:
        """Clean up temp files."""
        if self._temp_dir:
            shutil.rmtree(self._temp_dir, ignore_errors=True)
            self._temp_dir = None
        self._initialized = False
        logger.info(f"Cleaned up {self.name} backend")
'''


# =============================================================================
# API SERVER ADAPTER TEMPLATE
# =============================================================================

API_SERVER_ADAPTER = '''"""${display_name} Backend Adapter.

Auto-generated by Proxima Backend Wizard (Phase 3).
Backend Type: API Server
Version: ${version}
${author_line}

${description}
"""

from __future__ import annotations

from typing import Any, Dict, List, Optional
import logging
import time

try:
    import httpx
    HTTPX_AVAILABLE = True
except ImportError:
    HTTPX_AVAILABLE = False

from proxima.backends.base import (
    BaseBackendAdapter,
    Capabilities,
    SimulatorType,
    ValidationResult,
    ResourceEstimate,
    ExecutionResult,
    ResultType,
)
from .errors import (
    BackendError,
    InitializationError,
    ExecutionError,
    ValidationError,
)
from .normalizer import ${class_name}Normalizer

logger = logging.getLogger(__name__)


class ${class_name}Adapter(BaseBackendAdapter):
    """API server adapter for ${display_name}.
    
    ${description}
    
    Communicates with a quantum computing API server
    to execute circuits remotely.
    """
    
    name = "${backend_name}"
    version = "${version}"
    
    # Default API configuration
    DEFAULT_API_URL = "${api_url}"
    DEFAULT_TIMEOUT = 60
    
    def __init__(self, config: Dict[str, Any] = None):
        """Initialize API adapter.
        
        Args:
            config: Configuration with api_url, api_key, timeout, etc.
        """
        if not HTTPX_AVAILABLE:
            raise ImportError(
                "httpx is required for API backends. "
                "Install with: pip install httpx"
            )
        
        self.config = config or {}
        self._client = None
        self._initialized = False
        self._normalizer = ${class_name}Normalizer()
        
        self.api_url = self.config.get('api_url', self.DEFAULT_API_URL)
        self.api_key = self.config.get('api_key', '')
        self.timeout = self.config.get('timeout', self.DEFAULT_TIMEOUT)
        
        logger.info(f"Created {self.name} API adapter v{self.version}")
    
    def get_name(self) -> str:
        return self.name
    
    def get_version(self) -> str:
        return self.version
    
    def get_capabilities(self) -> Capabilities:
        return Capabilities(
            simulator_types=[SimulatorType.STATE_VECTOR],
            max_qubits=${max_qubits},
            supports_noise=${supports_noise},
            supports_gpu=${supports_gpu},
            supports_batching=True,  # APIs often support batching
        )
    
    def initialize(self) -> None:
        """Initialize HTTP client and verify connection."""
        if self._initialized:
            return
        
        headers = {
            "Content-Type": "application/json",
            "User-Agent": f"Proxima/${version}",
        }
        
        if self.api_key:
            headers["Authorization"] = f"Bearer {self.api_key}"
        
        self._client = httpx.Client(
            base_url=self.api_url,
            headers=headers,
            timeout=self.timeout
        )
        
        # Verify API is reachable
        try:
            response = self._client.get("/health")
            if response.status_code != 200:
                raise InitializationError(
                    f"API health check failed: {response.status_code}"
                )
        except httpx.RequestError as e:
            raise InitializationError(
                f"Cannot connect to API at {self.api_url}: {e}"
            )
        
        self._initialized = True
        logger.info(f"Initialized {self.name} API adapter")
    
    def validate_circuit(self, circuit: Any) -> ValidationResult:
        """Validate circuit for API execution."""
        if not circuit:
            return ValidationResult(valid=False, message="Circuit is empty")
        
        num_qubits = getattr(circuit, 'num_qubits', 0)
        if num_qubits > ${max_qubits}:
            return ValidationResult(
                valid=False,
                message=f"Too many qubits: {num_qubits}"
            )
        
        return ValidationResult(valid=True)
    
    def estimate_resources(self, circuit: Any) -> ResourceEstimate:
        # API execution time depends on server
        return ResourceEstimate(memory_mb=0, time_ms=5000)
    
    def execute(
        self,
        circuit: Any,
        options: Dict[str, Any] = None
    ) -> ExecutionResult:
        """Execute circuit via API."""
        if not self._initialized:
            self.initialize()
        
        options = options or {}
        shots = options.get('shots', 1024)
        
        start_time = time.time()
        
        # Convert circuit to API format
        circuit_data = self._convert_to_api_format(circuit)
        
        payload = {
            "circuit": circuit_data,
            "shots": shots,
            "options": options.get('api_options', {})
        }
        
        try:
            response = self._client.post(
                "/execute",
                json=payload
            )
            response.raise_for_status()
            raw_result = response.json()
            
        except httpx.HTTPStatusError as e:
            raise ExecutionError(
                f"API returned error {e.response.status_code}: "
                f"{e.response.text}"
            )
        except httpx.RequestError as e:
            raise ExecutionError(f"API request failed: {e}")
        
        execution_time = (time.time() - start_time) * 1000
        normalized = self._normalizer.normalize(raw_result)
        
        return ExecutionResult(
            backend=self.name,
            simulator_type=SimulatorType.STATE_VECTOR,
            execution_time_ms=execution_time,
            qubit_count=getattr(circuit, 'num_qubits', 0),
            shot_count=shots,
            result_type=ResultType.COUNTS,
            data=normalized,
            raw_result=raw_result,
        )
    
    def _convert_to_api_format(self, circuit: Any) -> Dict[str, Any]:
        """Convert circuit to API-expected format."""
        gates = []
        for gate in getattr(circuit, 'gates', []):
            gates.append({
                'name': gate.name,
                'qubits': list(gate.qubits),
                'params': list(getattr(gate, 'params', []))
            })
        
        return {
            'version': '1.0',
            'num_qubits': getattr(circuit, 'num_qubits', 0),
            'gates': gates
        }
    
    def supports_simulator(self, sim_type: SimulatorType) -> bool:
        return sim_type == SimulatorType.STATE_VECTOR
    
    def is_available(self) -> bool:
        """Check if API is reachable."""
        try:
            with httpx.Client(timeout=5) as client:
                response = client.get(f"{self.api_url}/health")
                return response.status_code == 200
        except Exception:
            return False
    
    def cleanup(self) -> None:
        """Close HTTP client."""
        if self._client:
            self._client.close()
            self._client = None
        self._initialized = False
        logger.info(f"Cleaned up {self.name} API adapter")
'''


# =============================================================================
# CUSTOM ADAPTER TEMPLATE
# =============================================================================

CUSTOM_ADAPTER = '''"""${display_name} Backend Adapter.

Auto-generated by Proxima Backend Wizard (Phase 3).
Backend Type: Custom
Version: ${version}
${author_line}

${description}

This is a minimal template for fully custom backends.
Implement the required methods according to your backend's needs.
"""

from __future__ import annotations

from typing import Any, Dict, List, Optional
import logging
import time

from proxima.backends.base import (
    BaseBackendAdapter,
    Capabilities,
    SimulatorType,
    ValidationResult,
    ResourceEstimate,
    ExecutionResult,
    ResultType,
)

logger = logging.getLogger(__name__)


class ${class_name}Adapter(BaseBackendAdapter):
    """Custom adapter for ${display_name}.
    
    ${description}
    
    TODO: Implement the required methods for your backend.
    """
    
    name = "${backend_name}"
    version = "${version}"
    
    def __init__(self, config: Dict[str, Any] = None):
        """Initialize the adapter.
        
        Args:
            config: Backend-specific configuration
        """
        self.config = config or {}
        self._initialized = False
        logger.info(f"Created {self.name} adapter v{self.version}")
    
    def get_name(self) -> str:
        return self.name
    
    def get_version(self) -> str:
        return self.version
    
    def get_capabilities(self) -> Capabilities:
        """Return backend capabilities.
        
        TODO: Customize based on your backend's actual capabilities.
        """
        return Capabilities(
            simulator_types=[SimulatorType.STATE_VECTOR],
            max_qubits=${max_qubits},
            supports_noise=${supports_noise},
            supports_gpu=${supports_gpu},
            supports_batching=False,
        )
    
    def initialize(self) -> None:
        """Initialize the backend.
        
        TODO: Add your initialization logic here.
        """
        if self._initialized:
            return
        
        # TODO: Initialize your backend
        # Example:
        # self._backend = YourBackend(**self.config)
        
        self._initialized = True
        logger.info(f"Initialized {self.name} backend")
    
    def validate_circuit(self, circuit: Any) -> ValidationResult:
        """Validate circuit compatibility.
        
        TODO: Add your validation logic here.
        """
        if not circuit:
            return ValidationResult(valid=False, message="Circuit is empty")
        
        return ValidationResult(valid=True)
    
    def estimate_resources(self, circuit: Any) -> ResourceEstimate:
        """Estimate execution resources.
        
        TODO: Add your estimation logic here.
        """
        return ResourceEstimate(memory_mb=100, time_ms=1000)
    
    def execute(
        self,
        circuit: Any,
        options: Dict[str, Any] = None
    ) -> ExecutionResult:
        """Execute a circuit.
        
        TODO: Implement your execution logic here.
        """
        if not self._initialized:
            self.initialize()
        
        options = options or {}
        shots = options.get('shots', 1024)
        
        start_time = time.time()
        
        # TODO: Implement circuit execution
        # Example:
        # result = self._backend.run(circuit, shots=shots)
        
        # Placeholder result
        counts = {"0" * circuit.num_qubits: shots}
        
        execution_time = (time.time() - start_time) * 1000
        
        return ExecutionResult(
            backend=self.name,
            simulator_type=SimulatorType.STATE_VECTOR,
            execution_time_ms=execution_time,
            qubit_count=getattr(circuit, 'num_qubits', 0),
            shot_count=shots,
            result_type=ResultType.COUNTS,
            data={"counts": counts},
            raw_result=counts,
        )
    
    def supports_simulator(self, sim_type: SimulatorType) -> bool:
        return sim_type == SimulatorType.STATE_VECTOR
    
    def is_available(self) -> bool:
        """Check if backend is available.
        
        TODO: Add your availability check here.
        """
        return True
    
    def cleanup(self) -> None:
        """Clean up resources.
        
        TODO: Add your cleanup logic here.
        """
        self._initialized = False
        logger.info(f"Cleaned up {self.name} backend")
'''


# =============================================================================
# NORMALIZER TEMPLATE
# =============================================================================

NORMALIZER = '''"""Result normalizer for ${display_name}.

Auto-generated by Proxima Backend Wizard (Phase 3).
"""

from __future__ import annotations

from typing import Dict, Any, Optional, List
import logging

logger = logging.getLogger(__name__)


class ${class_name}Normalizer:
    """Normalize results from ${display_name}.
    
    Converts backend-specific result formats to Proxima's
    standard format for consistent result handling.
    """
    
    def normalize(self, raw_result: Any) -> Dict[str, Any]:
        """Convert backend-specific result to Proxima format.
        
        Args:
            raw_result: Raw result from the backend
            
        Returns:
            Normalized result dictionary with counts and metadata
        """
        counts = self._extract_counts(raw_result)
        normalized_counts = self._normalize_counts(counts)
        
        return {
            'counts': normalized_counts,
            'shots': sum(normalized_counts.values()),
            'success': True,
        }
    
    def _extract_counts(self, raw_result: Any) -> Dict[str, int]:
        """Extract count data from various result formats."""
        if isinstance(raw_result, dict):
            return raw_result.get('counts', {})
        elif hasattr(raw_result, 'measurements'):
            return dict(raw_result.measurements)
        elif hasattr(raw_result, 'get_counts'):
            return raw_result.get_counts()
        return {}
    
    def _normalize_counts(self, counts: Dict[str, int]) -> Dict[str, int]:
        """Normalize state strings in counts."""
        normalized = {}
        for state, count in counts.items():
            norm_state = self._normalize_state(state)
            normalized[norm_state] = normalized.get(norm_state, 0) + count
        return normalized
    
    def _normalize_state(self, state: str) -> str:
        """Normalize state string to standard binary format."""
        state = str(state).strip("|<> ")
        
        if state.startswith('0b'):
            state = state[2:]
        
        if all(c in '01' for c in state):
            return state
        
        try:
            return format(int(state), 'b')
        except ValueError:
            return state
    
    def extract_probabilities(self, raw_result: Any) -> Optional[Dict[str, float]]:
        """Extract probability distribution."""
        normalized = self.normalize(raw_result)
        counts = normalized.get('counts', {})
        total = sum(counts.values())
        
        if total > 0:
            return {state: count / total for state, count in counts.items()}
        return None
    
    def extract_statevector(self, raw_result: Any) -> Optional[List[complex]]:
        """Extract statevector if available."""
        if hasattr(raw_result, 'statevector'):
            return list(raw_result.statevector)
        elif isinstance(raw_result, dict) and 'statevector' in raw_result:
            return raw_result['statevector']
        return None
'''


# =============================================================================
# CONVERTER TEMPLATE
# =============================================================================

CONVERTER = '''"""Circuit converter for ${backend_name}.

Auto-generated by Proxima Backend Wizard (Phase 3).
"""

from __future__ import annotations

from typing import Any, Dict, List
import logging

logger = logging.getLogger(__name__)


class CircuitConverter:
    """Convert Proxima circuits to various formats."""
    
    GATE_MAPPING = {
        "H": "hadamard",
        "X": "pauli_x",
        "Y": "pauli_y",
        "Z": "pauli_z",
        "CNOT": "cnot",
        "CX": "cx",
        "SWAP": "swap",
        "RX": "rx",
        "RY": "ry",
        "RZ": "rz",
    }
    
    def convert(self, circuit: Any, target_format: str = "native") -> Any:
        """Convert circuit to specified format."""
        if target_format == "qasm":
            return self.to_qasm(circuit)
        elif target_format == "json":
            return self.to_json(circuit)
        else:
            return self.to_native(circuit)
    
    def to_native(self, circuit: Any) -> Dict[str, Any]:
        """Convert to native backend format."""
        return {
            'num_qubits': getattr(circuit, 'num_qubits', 0),
            'gates': [self._convert_gate(g) for g in getattr(circuit, 'gates', [])]
        }
    
    def _convert_gate(self, gate: Any) -> Dict[str, Any]:
        """Convert single gate."""
        name = getattr(gate, 'name', '').upper()
        return {
            'name': self.GATE_MAPPING.get(name, name.lower()),
            'qubits': list(getattr(gate, 'qubits', [])),
            'params': list(getattr(gate, 'params', [])),
        }
    
    def to_qasm(self, circuit: Any) -> str:
        """Convert to OpenQASM 2.0 format."""
        num_qubits = getattr(circuit, 'num_qubits', 0)
        lines = [
            'OPENQASM 2.0;',
            'include "qelib1.inc";',
            f'qreg q[{num_qubits}];',
            f'creg c[{num_qubits}];',
        ]
        
        for gate in getattr(circuit, 'gates', []):
            lines.append(self._gate_to_qasm(gate))
        
        return '\\n'.join(lines)
    
    def _gate_to_qasm(self, gate: Any) -> str:
        """Convert gate to QASM instruction."""
        name = gate.name.lower()
        qubits = ','.join(f'q[{q}]' for q in gate.qubits)
        params = getattr(gate, 'params', [])
        
        if params:
            param_str = ','.join(str(p) for p in params)
            return f'{name}({param_str}) {qubits};'
        return f'{name} {qubits};'
    
    def to_json(self, circuit: Any) -> Dict[str, Any]:
        """Convert to JSON-serializable format."""
        return {
            'version': '1.0',
            'num_qubits': getattr(circuit, 'num_qubits', 0),
            'gates': [
                {
                    'name': g.name,
                    'qubits': list(g.qubits),
                    'params': list(getattr(g, 'params', []))
                }
                for g in getattr(circuit, 'gates', [])
            ]
        }
'''


# =============================================================================
# ERRORS TEMPLATE
# =============================================================================

ERRORS = '''"""Error definitions for ${backend_name}.

Auto-generated by Proxima Backend Wizard (Phase 3).
"""


class BackendError(Exception):
    """Base exception for backend errors."""
    pass


class InitializationError(BackendError):
    """Error during backend initialization."""
    pass


class ExecutionError(BackendError):
    """Error during circuit execution."""
    pass


class ValidationError(BackendError):
    """Error during circuit validation."""
    pass


class ResourceError(BackendError):
    """Error due to insufficient resources."""
    pass


class ConfigurationError(BackendError):
    """Error in backend configuration."""
    pass


def handle_error(error: Exception) -> BackendError:
    """Convert generic exceptions to backend-specific errors."""
    msg = str(error).lower()
    
    if 'memory' in msg or 'resource' in msg:
        return ResourceError(str(error))
    elif 'import' in msg or 'module' in msg:
        return InitializationError(str(error))
    elif 'invalid' in msg or 'unsupported' in msg:
        return ValidationError(str(error))
    elif 'config' in msg:
        return ConfigurationError(str(error))
    else:
        return ExecutionError(str(error))
'''


# =============================================================================
# INIT TEMPLATE
# =============================================================================

INIT = '''"""${display_name} backend module.

Auto-generated by Proxima Backend Wizard (Phase 3).
"""

from .adapter import ${class_name}Adapter
from .normalizer import ${class_name}Normalizer
from .converter import CircuitConverter
from .errors import (
    BackendError,
    InitializationError,
    ExecutionError,
    ValidationError,
    ResourceError,
    ConfigurationError,
)

__all__ = [
    "${class_name}Adapter",
    "${class_name}Normalizer",
    "CircuitConverter",
    "BackendError",
    "InitializationError",
    "ExecutionError",
    "ValidationError",
    "ResourceError",
    "ConfigurationError",
]


def get_adapter(**kwargs):
    """Factory function to create adapter instance."""
    return ${class_name}Adapter(config=kwargs)
'''


# =============================================================================
# README TEMPLATE
# =============================================================================

README = '''# ${display_name}

${description}

## Overview

| Property | Value |
|----------|-------|
| Backend Name | `${backend_name}` |
| Version | ${version} |
| Type | ${backend_type} |
| Max Qubits | ${max_qubits} |
| Noise Support | ${supports_noise} |
| GPU Support | ${supports_gpu} |

## Installation

```bash
${install_command}
```

## Quick Start

```python
from proxima.backends.${backend_name} import ${class_name}Adapter

# Create adapter
adapter = ${class_name}Adapter()
adapter.initialize()

# Check capabilities
caps = adapter.get_capabilities()
print(f"Max qubits: {caps.max_qubits}")

# Execute a circuit
result = adapter.execute(circuit, options={'shots': 1024})
print(f"Counts: {result.data['counts']}")

# Clean up
adapter.cleanup()
```

## Configuration

```python
adapter = ${class_name}Adapter(config={
    'shots': 1024,
    # Add backend-specific options
})
```

## Supported Gates

- Single qubit: H, X, Y, Z, S, T, RX, RY, RZ
- Two qubit: CNOT, CX, CZ, SWAP
- Three qubit: CCX (Toffoli), CSWAP (Fredkin)

## API Reference

### ${class_name}Adapter

Main adapter class.

**Methods:**
- `initialize()` - Initialize backend
- `execute(circuit, options)` - Execute circuit
- `validate_circuit(circuit)` - Validate circuit
- `get_capabilities()` - Get backend capabilities
- `cleanup()` - Release resources

## Metadata

- **Generated by:** Proxima Backend Wizard (Phase 3)
- **Version:** ${version}
${author_line}
'''


# =============================================================================
# TESTS TEMPLATE
# =============================================================================

TESTS = '''"""Tests for ${display_name} backend.

Auto-generated by Proxima Backend Wizard (Phase 3).
"""

import pytest
from unittest.mock import MagicMock, patch

from proxima.backends.${backend_name} import ${class_name}Adapter
from proxima.backends.${backend_name}.errors import (
    BackendError,
    InitializationError,
    ExecutionError,
    ValidationError,
)


class Test${class_name}Adapter:
    """Test suite for ${class_name}Adapter."""
    
    @pytest.fixture
    def adapter(self):
        """Create adapter instance."""
        adapter = ${class_name}Adapter()
        yield adapter
        adapter.cleanup()
    
    def test_get_name(self, adapter):
        """Test backend name."""
        assert adapter.get_name() == "${backend_name}"
    
    def test_get_version(self, adapter):
        """Test backend version."""
        assert adapter.get_version() == "${version}"
    
    def test_get_capabilities(self, adapter):
        """Test capabilities."""
        caps = adapter.get_capabilities()
        assert caps.max_qubits == ${max_qubits}
        assert len(caps.simulator_types) > 0
    
    def test_validate_empty_circuit(self, adapter):
        """Test validation rejects empty circuit."""
        result = adapter.validate_circuit(None)
        assert not result.valid
    
    def test_validate_valid_circuit(self, adapter):
        """Test validation accepts valid circuit."""
        circuit = MagicMock()
        circuit.num_qubits = 2
        circuit.gates = []
        
        result = adapter.validate_circuit(circuit)
        assert result.valid
    
    def test_validate_too_many_qubits(self, adapter):
        """Test validation rejects too many qubits."""
        circuit = MagicMock()
        circuit.num_qubits = ${max_qubits} + 10
        
        result = adapter.validate_circuit(circuit)
        assert not result.valid
    
    def test_estimate_resources(self, adapter):
        """Test resource estimation."""
        circuit = MagicMock()
        circuit.num_qubits = 4
        circuit.gates = [MagicMock() for _ in range(10)]
        
        estimate = adapter.estimate_resources(circuit)
        assert estimate.memory_mb > 0
    
    def test_is_available(self):
        """Test availability check."""
        adapter = ${class_name}Adapter()
        result = adapter.is_available()
        assert isinstance(result, bool)


class Test${class_name}Normalizer:
    """Test normalizer."""
    
    def test_normalize_dict(self):
        """Test normalizing dict result."""
        from proxima.backends.${backend_name} import ${class_name}Normalizer
        
        normalizer = ${class_name}Normalizer()
        result = normalizer.normalize({'counts': {'00': 50, '11': 50}})
        
        assert 'counts' in result
        assert result['shots'] == 100


class TestCircuitConverter:
    """Test circuit converter."""
    
    def test_to_json(self):
        """Test JSON conversion."""
        from proxima.backends.${backend_name} import CircuitConverter
        
        converter = CircuitConverter()
        circuit = MagicMock()
        circuit.num_qubits = 2
        circuit.gates = []
        
        result = converter.to_json(circuit)
        assert result['num_qubits'] == 2
'''


# =============================================================================
# CONFIG TEMPLATE
# =============================================================================

CONFIG = '''# Configuration for ${display_name} backend
# Auto-generated by Proxima Backend Wizard (Phase 3)

backend:
  name: ${backend_name}
  version: ${version}
  type: ${backend_type}

capabilities:
  max_qubits: ${max_qubits}
  supports_noise: ${supports_noise}
  supports_gpu: ${supports_gpu}
  supports_batching: false

defaults:
  shots: 1024
  seed: null

# Backend-specific configuration
${backend_type}:
  # Add backend-specific settings here
  pass
'''
