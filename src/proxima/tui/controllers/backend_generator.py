"""Backend Code Generator Controller.

Generates complete backend implementation files based on wizard configuration.
Uses the BackendTemplateEngine for code generation.
"""

from __future__ import annotations

from pathlib import Path
from typing import Dict, List, Tuple, Optional, Any
import logging

from ..utils.backend_templates import BackendTemplateEngine

logger = logging.getLogger(__name__)


class BackendCodeGenerator:
    """Generate backend code files from wizard configuration.
    
    Creates a complete backend package including:
    - adapter.py: Main backend adapter implementation
    - normalizer.py: Result normalization
    - __init__.py: Package initialization
    - README.md: Documentation
    - test file: Unit tests
    """
    
    def __init__(self, state: Any):
        """Initialize generator with wizard state.
        
        Args:
            state: BackendWizardState containing all configuration
        """
        self.state = state
        self.template_engine = BackendTemplateEngine()
        self.output_dir = Path("src/proxima/backends") / getattr(state, 'backend_name', 'custom')
    
    def generate_all_files(self) -> Tuple[bool, List[str], Dict[str, str]]:
        """Generate all backend files.
        
        Returns:
            Tuple of (success, file_paths, file_contents)
        """
        try:
            files: Dict[str, str] = {}
            backend_name = getattr(self.state, 'backend_name', 'custom_backend')
            
            # Generate adapter.py
            adapter_code = self._generate_adapter()
            files[f"{backend_name}/adapter.py"] = adapter_code
            
            # Generate normalizer.py
            normalizer_code = self._generate_normalizer()
            files[f"{backend_name}/normalizer.py"] = normalizer_code
            
            # Generate __init__.py
            init_code = self._generate_init()
            files[f"{backend_name}/__init__.py"] = init_code
            
            # Generate README.md
            readme_code = self._generate_readme()
            files[f"{backend_name}/README.md"] = readme_code
            
            # Generate tests
            test_code = self._generate_tests()
            files[f"tests/backends/test_{backend_name}.py"] = test_code
            
            file_paths = list(files.keys())
            
            logger.info(f"Generated {len(files)} files for backend '{backend_name}'")
            
            return True, file_paths, files
            
        except Exception as e:
            logger.error(f"Error generating backend files: {e}", exc_info=True)
            return False, [], {"error": str(e)}
    
    def _generate_adapter(self) -> str:
        """Generate adapter.py content."""
        backend_type = getattr(self.state, 'backend_type', 'custom')
        
        # Get gate mappings from state
        gate_mappings = {}
        if hasattr(self.state, 'gate_mappings'):
            for gate_name, mapping in self.state.gate_mappings.items():
                if hasattr(mapping, 'backend_gate'):
                    gate_mappings[gate_name] = mapping.backend_gate
                else:
                    gate_mappings[gate_name] = str(mapping)
        
        return self.template_engine.render_adapter(
            backend_type=backend_type,
            backend_name=getattr(self.state, 'backend_name', 'custom'),
            display_name=getattr(self.state, 'display_name', 'Custom Backend'),
            version=getattr(self.state, 'version', '1.0.0'),
            description=getattr(self.state, 'description', ''),
            author=getattr(self.state, 'author', ''),
            library_name=getattr(self.state, 'library_name', ''),
            simulator_types=getattr(self.state, 'simulator_types', ['state_vector']),
            max_qubits=getattr(self.state, 'max_qubits', 20),
            supports_noise=getattr(self.state, 'supports_noise', False),
            supports_gpu=getattr(self.state, 'supports_gpu', False),
            supports_batching=getattr(self.state, 'supports_batching', False),
            custom_init=getattr(self.state, 'custom_initialization_code', ''),
            custom_execute=getattr(self.state, 'custom_execution_code', ''),
            gate_mappings=gate_mappings,
        )
    
    def _generate_normalizer(self) -> str:
        """Generate normalizer.py content."""
        backend_name = getattr(self.state, 'backend_name', 'custom')
        display_name = getattr(self.state, 'display_name', 'Custom Backend')
        normalizer_class = self._to_class_name(backend_name) + "Normalizer"
        
        return f'''"""Result normalizer for {display_name}.

Auto-generated by Proxima Backend Wizard.
"""

from __future__ import annotations

from typing import Dict, Any, Optional
import logging

logger = logging.getLogger(__name__)


class {normalizer_class}:
    """Normalize results from {display_name}.
    
    Converts backend-specific result formats to Proxima's
    standard ExecutionResult format.
    """
    
    def normalize(self, raw_result: Any) -> Dict[str, Any]:
        """
        Convert backend-specific result to Proxima format.
        
        Args:
            raw_result: Raw result from {display_name}
        
        Returns:
            Dictionary with normalized results
        """
        counts = {{}}
        
        # Extract counts from various formats
        if isinstance(raw_result, dict):
            counts = raw_result.get('counts', {{}})
        elif hasattr(raw_result, 'measurements'):
            counts = raw_result.measurements
        elif hasattr(raw_result, 'get_counts'):
            counts = raw_result.get_counts()
        
        # Normalize state strings to binary format
        normalized_counts = {{}}
        for state, count in counts.items():
            normalized_state = self._normalize_state(state)
            normalized_counts[normalized_state] = count
        
        return {{
            'counts': normalized_counts,
            'shots': sum(normalized_counts.values()),
            'success': True,
        }}
    
    def _normalize_state(self, state: str) -> str:
        """Normalize state string representation.
        
        Converts various state formats to standard binary string.
        
        Args:
            state: State string in any format
            
        Returns:
            Binary string representation (e.g., "00", "01", "10", "11")
        """
        # Remove common prefixes/suffixes
        state = str(state).strip("|<> ")
        
        # Remove any 0b prefix
        if state.startswith('0b'):
            state = state[2:]
        
        # Already binary format
        if all(c in '01' for c in state):
            return state
        
        # Try to convert from integer
        try:
            value = int(state)
            return format(value, 'b')
        except ValueError:
            pass
        
        # Return as-is if we can't normalize
        logger.warning(f"Could not normalize state: {{state}}")
        return state
    
    def extract_statevector(self, raw_result: Any) -> Optional[list]:
        """Extract statevector if available.
        
        Args:
            raw_result: Raw result from backend
            
        Returns:
            List of complex amplitudes or None
        """
        if hasattr(raw_result, 'statevector'):
            return list(raw_result.statevector)
        elif isinstance(raw_result, dict) and 'statevector' in raw_result:
            return raw_result['statevector']
        return None
    
    def extract_probabilities(self, raw_result: Any) -> Optional[Dict[str, float]]:
        """Extract probability distribution if available.
        
        Args:
            raw_result: Raw result from backend
            
        Returns:
            Dictionary mapping states to probabilities or None
        """
        if hasattr(raw_result, 'probabilities'):
            return dict(raw_result.probabilities)
        elif isinstance(raw_result, dict) and 'probabilities' in raw_result:
            return raw_result['probabilities']
        
        # Calculate from counts if available
        normalized = self.normalize(raw_result)
        counts = normalized.get('counts', {{}})
        total = sum(counts.values())
        
        if total > 0:
            return {{state: count / total for state, count in counts.items()}}
        
        return None
'''
    
    def _generate_init(self) -> str:
        """Generate __init__.py content."""
        backend_name = getattr(self.state, 'backend_name', 'custom')
        adapter_class = self._to_class_name(backend_name) + "Adapter"
        normalizer_class = self._to_class_name(backend_name) + "Normalizer"
        display_name = getattr(self.state, 'display_name', 'Custom Backend')
        
        return f'''"""{display_name} backend module.

Auto-generated by Proxima Backend Wizard.

This module provides integration with {display_name} for quantum circuit execution.
"""

from .adapter import {adapter_class}
from .normalizer import {normalizer_class}

__all__ = ["{adapter_class}", "{normalizer_class}"]


def get_adapter(**kwargs):
    """Factory function to create an adapter instance.
    
    Args:
        **kwargs: Configuration options for the adapter
        
    Returns:
        Initialized {adapter_class} instance
    """
    adapter = {adapter_class}(config=kwargs)
    return adapter
'''
    
    def _generate_readme(self) -> str:
        """Generate README.md content."""
        backend_name = getattr(self.state, 'backend_name', 'custom')
        display_name = getattr(self.state, 'display_name', 'Custom Backend')
        description = getattr(self.state, 'description', 'Custom quantum computing backend.')
        version = getattr(self.state, 'version', '1.0.0')
        author = getattr(self.state, 'author', '')
        library_name = getattr(self.state, 'library_name', '')
        max_qubits = getattr(self.state, 'max_qubits', 20)
        simulator_types = getattr(self.state, 'simulator_types', ['state_vector'])
        supports_noise = getattr(self.state, 'supports_noise', False)
        supports_gpu = getattr(self.state, 'supports_gpu', False)
        
        adapter_class = self._to_class_name(backend_name) + "Adapter"
        
        features = []
        if supports_noise:
            features.append("- ✅ Noise simulation")
        if supports_gpu:
            features.append("- ✅ GPU acceleration")
        features_str = "\n".join(features) if features else "- Basic simulation"
        
        install_cmd = f"pip install {library_name}" if library_name else "# Follow installation instructions"
        
        return f'''# {display_name}

{description}

## Overview

- **Backend Name**: `{backend_name}`
- **Version**: {version}
{f"- **Author**: {author}" if author else ""}
- **Max Qubits**: {max_qubits}
- **Simulator Types**: {", ".join(simulator_types)}

## Features

{features_str}

## Installation

```bash
{install_cmd}
```

## Usage

```python
from proxima.backends.{backend_name} import {adapter_class}

# Create and initialize adapter
adapter = {adapter_class}()
adapter.initialize()

# Check capabilities
caps = adapter.get_capabilities()
print(f"Max qubits: {{caps.max_qubits}}")

# Execute a circuit
result = adapter.execute(circuit, options={{'shots': 1024}})
print(f"Counts: {{result.data['counts']}}")

# Clean up
adapter.cleanup()
```

## Configuration

Configuration options can be passed to the adapter:

```python
adapter = {adapter_class}(config={{
    'shots': 1024,
    # Add more options here
}})
```

## API Reference

### {adapter_class}

Main adapter class for {display_name}.

**Methods:**

- `initialize()`: Initialize the backend
- `execute(circuit, options)`: Execute a quantum circuit
- `get_capabilities()`: Get backend capabilities
- `validate_circuit(circuit)`: Validate circuit compatibility
- `cleanup()`: Release resources

## Metadata

- **Version**: {version}
- **Generated by**: Proxima Backend Wizard
- **Generation Date**: Auto-generated

## License

Same as Proxima project.
'''
    
    def _generate_tests(self) -> str:
        """Generate test file content."""
        backend_name = getattr(self.state, 'backend_name', 'custom')
        display_name = getattr(self.state, 'display_name', 'Custom Backend')
        adapter_class = self._to_class_name(backend_name) + "Adapter"
        max_qubits = getattr(self.state, 'max_qubits', 20)
        
        return f'''"""Tests for {display_name} backend.

Auto-generated by Proxima Backend Wizard.
"""

import pytest
from unittest.mock import MagicMock, patch

# Import the backend
from proxima.backends.{backend_name} import {adapter_class}


class Test{adapter_class}:
    """Test suite for {adapter_class}."""
    
    @pytest.fixture
    def adapter(self):
        """Create adapter instance for testing."""
        adapter = {adapter_class}()
        yield adapter
        if hasattr(adapter, 'cleanup'):
            adapter.cleanup()
    
    def test_get_name(self, adapter):
        """Test backend name."""
        assert adapter.get_name() == "{backend_name}"
    
    def test_get_version(self, adapter):
        """Test backend version."""
        version = adapter.get_version()
        assert isinstance(version, str)
        assert len(version) > 0
    
    def test_get_capabilities(self, adapter):
        """Test capabilities reporting."""
        caps = adapter.get_capabilities()
        assert caps.max_qubits == {max_qubits}
        assert len(caps.simulator_types) > 0
    
    def test_validate_empty_circuit(self, adapter):
        """Test validation rejects empty circuit."""
        result = adapter.validate_circuit(None)
        assert not result.valid
    
    def test_is_available(self):
        """Test availability check."""
        result = {adapter_class}().is_available()
        assert isinstance(result, bool)
    
    def test_estimate_resources(self, adapter):
        """Test resource estimation."""
        # Create mock circuit
        mock_circuit = MagicMock()
        mock_circuit.num_qubits = 4
        mock_circuit.gate_count = 10
        
        estimate = adapter.estimate_resources(mock_circuit)
        assert estimate.memory_mb > 0
        assert estimate.time_ms >= 0
    
    @pytest.mark.skipif(
        not {adapter_class}().is_available(),
        reason="Backend not available"
    )
    def test_execute_mock_circuit(self, adapter):
        """Test execution with mock circuit."""
        adapter.initialize()
        
        # Create mock circuit
        mock_circuit = MagicMock()
        mock_circuit.num_qubits = 2
        
        # Note: This may fail if backend isn't fully implemented
        # result = adapter.execute(mock_circuit, {{'shots': 100}})
        # assert result is not None


def test_adapter_initialization():
    """Test adapter can be created."""
    adapter = {adapter_class}()
    assert adapter is not None
    assert adapter.get_name() == "{backend_name}"


def test_gate_mapping():
    """Test gate mapping is defined."""
    adapter = {adapter_class}()
    mapping = adapter._get_gate_mapping()
    assert isinstance(mapping, dict)
'''
    
    def _to_class_name(self, snake_str: str) -> str:
        """Convert snake_case to CamelCase."""
        components = snake_str.replace("-", "_").split("_")
        return "".join(x.title() for x in components)
    
    def write_files_to_disk(self, files: Dict[str, str]) -> bool:
        """Write generated files to disk.
        
        Args:
            files: Dictionary of file_path -> content
        
        Returns:
            True if successful
        """
        try:
            base_path = Path("src/proxima/backends")
            base_path.mkdir(parents=True, exist_ok=True)
            
            for file_path, content in files.items():
                full_path = Path(file_path)
                
                # Handle relative paths
                if not full_path.is_absolute():
                    if file_path.startswith("tests/"):
                        full_path = Path(file_path)
                    else:
                        full_path = base_path.parent.parent / file_path
                
                full_path.parent.mkdir(parents=True, exist_ok=True)
                
                with open(full_path, 'w', encoding='utf-8') as f:
                    f.write(content)
                
                logger.info(f"Written: {full_path}")
            
            return True
            
        except Exception as e:
            logger.error(f"Error writing files: {e}", exc_info=True)
            return False
